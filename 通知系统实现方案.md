# 通知系统实现方案

## 系统概述

社交平台的实时通知系统，支持点赞、评论、关注等动作的即时通知推送，包含未读数量显示和实时更新功能。

## 技术方案选择

### 1. 实时通信技术对比

| 技术方案 | 优点 | 缺点 | 适用场景 |
|---------|------|------|----------|
| **WebSocket** | 真正双向通信、实时性最好 | 服务器资源消耗大、连接管理复杂 | 高频实时交互 |
| **Server-Sent Events (SSE)** | 简单易实现、自动重连 | 单向通信、IE不支持 | 服务器推送场景 |
| **长轮询 (Long Polling)** | 兼容性好、实现简单 | 性能较差、超时处理复杂 | 低频通知 |
| **短轮询 + 缓存** | 实现最简单、可控性强 | 实时性稍差、网络开销 | 中小型应用 |

### 2. 推荐方案：SSE + 数据库轮询

**选择理由：**
- 社交通知不需要双向通信，SSE的单向推送完全满足需求
- 实现复杂度适中，比WebSocket简单，比长轮询高效
- 自动重连机制，网络断开后可自动恢复
- 支持现代浏览器，兼容性良好

## 系统架构设计

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户操作      │    │   通知生成      │    │   实时推送      │
│                 │    │                 │    │                 │
│ 点赞/评论/关注  │───▶│ 创建通知记录    │───▶│ SSE推送给用户   │
│                 │    │ 更新未读计数    │    │ 更新前端状态    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │   数据库存储    │
                       │                 │
                       │ notifications   │
                       │ 表存储所有通知  │
                       └─────────────────┘
```

## 数据库设计

### Notification 表结构
```sql
model Notification {
  id        String   @id @default(cuid())
  type      NotificationType
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  
  // 关联字段
  userId    String   // 接收通知的用户
  creatorId String   // 触发通知的用户
  postId    String?  // 相关帖子（如果有）
  
  // 关系
  user      User @relation("userNotifications", fields: [userId], references: [id])
  creator   User @relation("notificationCreator", fields: [creatorId], references: [id])
  post      Post? @relation(fields: [postId], references: [id])
}

enum NotificationType {
  LIKE    // 点赞
  COMMENT // 评论
  FOLLOW  // 关注
}
```

## 实现步骤

### 第一阶段：基础通知系统
1. **数据库模型更新**
   - 验证 Notification 表结构
   - 创建通知生成函数

2. **通知生成逻辑**
   - 在点赞/评论/关注API中添加通知创建
   - 防止自己给自己发通知
   - 防止重复通知

3. **通知页面实现**
   - 通知列表页面 `/notifications`
   - 标记已读功能
   - 通知内容展示

### 第二阶段：实时推送系统
1. **SSE服务端实现**
   - 创建 `/api/notifications/stream` SSE端点
   - 实现通知推送逻辑
   - 连接管理和错误处理

2. **前端SSE客户端**
   - 建立SSE连接
   - 处理实时通知数据
   - 更新UI状态

3. **未读数量显示**
   - 导航栏未读数量徽标
   - 实时更新未读计数
   - 页面可见性API优化

### 第三阶段：优化和增强
1. **性能优化**
   - 通知去重策略
   - 数据库索引优化
   - 缓存策略

2. **用户体验**
   - 浏览器通知API
   - 声音提醒
   - 通知设置页面

## 核心代码结构

### 1. 通知生成服务
```typescript
// /src/lib/notifications.ts
class NotificationService {
  async createLikeNotification(postId: string, likerId: string)
  async createCommentNotification(postId: string, commenterId: string, content: string)
  async createFollowNotification(followerId: string, followedId: string)
  async getUnreadCount(userId: string)
  async markAsRead(notificationId: string)
}
```

### 2. SSE推送服务
```typescript
// /src/app/api/notifications/stream/route.ts
export async function GET(request: NextRequest) {
  // SSE流设置
  // 用户认证
  // 推送逻辑
}
```

### 3. 前端通知Hook
```typescript
// /src/hooks/useNotifications.ts
export function useNotifications() {
  // SSE连接管理
  // 通知状态管理
  // 未读数量更新
}
```

### 4. 通知组件
```typescript
// /src/components/notifications/NotificationBell.tsx
export function NotificationBell() {
  // 显示未读数量徽标
  // 点击跳转通知页面
}
```

## 实时性方案对比

### 方案A：纯SSE实时推送
- **优点**：真正实时，用户体验最佳
- **缺点**：服务器长连接压力大
- **适用**：活跃用户多的生产环境

### 方案B：SSE + 定时轮询混合
- **优点**：平衡实时性和性能
- **缺点**：实现复杂度稍高
- **适用**：中等规模应用

### 方案C：纯轮询 + 智能缓存
- **优点**：实现简单，可控性强
- **缺点**：实时性相对较差
- **适用**：开发阶段和小型应用

## 推荐实现路径

### 阶段1：快速原型（1-2天）
```typescript
// 使用简单轮询实现基础功能
setInterval(() => {
  fetchUnreadCount()
}, 30000) // 30秒轮询一次
```

### 阶段2：优化体验（2-3天）
```typescript
// 实现SSE推送
const eventSource = new EventSource('/api/notifications/stream')
eventSource.onmessage = (event) => {
  const notification = JSON.parse(event.data)
  updateNotificationState(notification)
}
```

### 阶段3：完善功能（1-2天）
- 浏览器通知权限
- 通知设置页面
- 性能监控和优化

## 用户界面设计

### 1. 导航栏通知图标
```jsx
<Button className="relative">
  <BellIcon />
  {unreadCount > 0 && (
    <span className="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">
      {unreadCount > 99 ? '99+' : unreadCount}
    </span>
  )}
</Button>
```

### 2. 通知列表页面
- 通知分组（今天、昨天、更早）
- 未读通知高亮显示
- 批量标记已读
- 通知类型图标区分

### 3. 实时通知弹窗
- 右上角toast提示
- 可配置显示时长
- 点击跳转相关内容

## 技术实现细节

### 1. 防重复通知策略
```sql
-- 确保同一用户对同一帖子的点赞只产生一次通知
CREATE UNIQUE INDEX idx_unique_like_notification 
ON notifications (userId, creatorId, postId, type) 
WHERE type = 'LIKE';
```

### 2. 性能优化策略
- 通知表分区（按时间）
- 已读通知定期清理
- 数据库连接池优化
- Redis缓存未读计数

### 3. 错误处理机制
- SSE连接断开自动重连
- 网络异常降级为轮询
- 推送失败重试机制

## 监控和指标

### 1. 关键指标
- 通知推送成功率
- 平均推送延迟
- SSE连接数量
- 未读通知处理率

### 2. 用户行为分析
- 通知点击率
- 通知类型偏好
- 活跃时间段分析

## 安全考虑

### 1. 认证和授权
- SSE连接需要JWT验证
- 通知只能推送给目标用户
- 防止通知伪造

### 2. 性能保护
- 单用户连接数限制
- 通知发送频率限制
- 恶意刷通知防护

## 部署注意事项

### 1. 开发环境
- 使用简单轮询方案
- 本地数据库测试
- 模拟通知生成

### 2. 生产环境
- 配置反向代理支持SSE
- 数据库读写分离
- 监控告警设置

## 总结

通知系统是社交平台的核心功能，建议采用**渐进式实现**策略：
1. 先实现基础的通知生成和存储
2. 再添加简单的轮询更新机制
3. 最后优化为SSE实时推送

这样既能快速上线核心功能，又为后续优化留下了空间。
